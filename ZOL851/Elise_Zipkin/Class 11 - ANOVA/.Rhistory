n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
?gl
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
library("lattice") # Load the lattice library
xyplot(wing ~elev|pop,ylab="Winglength",xlab="Elevation",main=
"Population-specific relationship between wing and elevation class")
xyplot(wing ~pop|elev,ylab="Winglength",xlab="Population",main=
"Elevation-specific relationship between wing and population")
X
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
n.pop <-5
n.elev <-3
nsample <-12
n <-n.pop*nsample
# Create factor levels
pop <-gl(n=n.pop,k=nsample,length=n)
elev <-gl(n=n.elev,k=nsample/n.elev,length=n)
# Choose effects
baseline <-40 #Intercept
pop.effects = c(-10, -5, 5,10) #Population effects
elev.effects  = c(5,10) #Elev effects
interaction.effects <- c(-2, 3,0,4,4,0,3, -2) #Interaction effects
all.effects <- c(baseline,pop.effects,elev.effects,interaction.effects)
sigma <- 3
eps <-rnorm(n,0,sigma) #Residuals
X <-as.matrix(model.matrix(~pop*elev)) #Create design matrix
X #Have a look at the design matrix
#Use matrix multiplication to assemble all components of the data
wing <-as.numeric(as.matrix(X)%*%as.matrix(all.effects)+eps)
#Plot the generated data
boxplot(wing ~elev*pop, col="grey",xlab="Elevation by Population", ylab=
"Wing length",main="Simulated data set", las=1,ylim=c(20,70))
abline(h =40)
library("lattice") # Load the lattice library
xyplot(wing ~elev|pop,ylab="Winglength",xlab="Elevation",main=
"Population-specific relationship between wing and elevation class")
xyplot(wing ~pop|elev,ylab="Winglength",xlab="Population",main=
"Elevation-specific relationship between wing and population")
all.effects
lm(wing ~ pop*elev)
n.iter <-1000 # Desired number of iterations
estimates <-array(dim=c(n.iter,length(all.effects))) #Data structure to hold results
for(i in 1:n.iter){  #Run simulation n.iter times
eps <- rnorm(n,0,sigma) #Residuals
y <- as.numeric(as.matrix(X) %*% as.matrix(all.effects)+eps) #Assemble data
fit.model <- lm(y ~ pop*elev)  #Break down data
estimates[i,] <- fit.model$coefficients  #Save estimates of coefs.
}
print(apply(estimates,2,mean),dig=2)  #What does the apply function do?
all.effects
mainfit = lm(wing ~elev+pop)
mainfit
intfit <-lm(wing ~ elev*pop -1 -pop -elev)
intfit
all.effects
#To the coefficient estimates  of the two-way interaction ANOVA model
lm(wing ~ pop*elev)
n.iter <-1000 # Desired number of iterations
estimates <-array(dim=c(n.iter,length(all.effects))) #Data structure to hold results
for(i in 1:n.iter){  #Run simulation n.iter times
eps <- rnorm(n,0,sigma) #Residuals
y <- as.numeric(as.matrix(X) %*% as.matrix(all.effects)+eps) #Assemble data
fit.model <- lm(y ~ pop*elev)  #Break down data
estimates[i,] <- fit.model$coefficients  #Save estimates of coefs.
}
print(apply(estimates,2,mean),dig=2)  #What does the apply function do?
all.effects
mainfit = lm(wing ~elev+pop)
mainfit
print(apply(estimates,2,mean),dig=2)  #What does the apply function do?
mainfit
intfit
